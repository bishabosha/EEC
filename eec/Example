package eec.report.example

primitive x + y : Integer -> Integer -> Integer
primitive s1 ++ s2 : String -> String -> String
primitive debug x : A -> String
primitive putStrLn s : String -> !()
primitive readInteger : !Integer
primitive a == b : A -> A -> Boolean
primitive eval [a] : A# -* ()

primitive absurd v : Void -> A
primitive Left  l : L -> Either L R
primitive Right r : R -> Either L R
primitive summon [v] : Void# -* A#
primitive InL [l] : L# -* L# |+| R#
primitive InR [r] : R# -* L# |+| R#

liftD : (A -> B#) -> !A -> B# =
  \(f: A -> B#)(x: !A) => let !y = x in f y

liftC : (A -> B) -> A -> !B =
  \(f: A -> B)(x: A) => !(f x)

const x _ : A -> B -> A =
  x

evalAbsurd f: (Void -> ()) -> () = ()

givenAbsurd: () = evalAbsurd absurd

safeDuplication [a] : A# -* () =
  | case (a, a) of
    (q, _) -* eval [q]
    (_, r) -* eval [r]

linearMatchInR: () =
  | case InR [()] of
    InR [m] -* m
    InL [n] -* ()

stateMake v [s] : V -> (S# -* !V |*| S#) =
  !v |*| s

contMake a [f] : A -> ((A -> R#) -* R#) =
  f a

evalTest: () =
  (| (a: ()) -* a)[()]

ma >>= f : !A -> (A -> !B) -> !B =
  (liftD f) ma

f =<< ma : (A -> !B) -> !A -> !B =
  ma >>= f

fst p: (A, B) -> A =
  case p of (a, _) => a

snd p: (A, B) -> B =
  case p of (_, b) => b

pairEq : Boolean = (fst (0,""), snd (0,"")) == (0,"")

earthDiameter : Decimal = 12.742e+10

u: Either y (Either () z) = Right (Left ())

movie : String = "12 Monkeys"

cat2 e lu ru : Either x y -> (x -> !u) -> (y -> !u) -> !u =
  case e of
    Left  a => lu a;
    Right b => ru b

cat3 e xu yu zu : Either (Either x y) z -> (x -> !u) -> (y -> !u) -> (z -> !u) -> !u =
  case e of
    Left  (Left a)  => xu a;
    Left  (Right b) => yu b;
    Right c         => zu c

cat4 e wu xu yu zu : Either (Either (Either w x) y) z -> (w -> !u) -> (x -> !u) -> (y -> !u) -> (z -> !u) -> !u =
  case e of
    Left  (Left  (Left  a)) => wu a;
    Left  (Left  (Right b)) => xu b;
    Left  (Right c)         => yu c;
    Right d                 => zu d

json : String = """{
  "title": "12 Monkeys",
  "director": "Terry Gilliam",
  "length": 129
}"""

nl : Char = '\n'

e : Char = 'e'

unit : () = ()

succ x : Integer -> Integer =
  x + 1

a `and` b : Boolean -> Boolean -> Boolean =
  if a then b else False

a `or` b : Boolean -> Boolean -> Boolean =
  if a then True else b

not b : Boolean -> Boolean =
  if True then False else True

isZero x : Integer -> Boolean =
  case x of
    0 => True
    _ => False

main : !() =
  let !x    = readInteger in
  if isZero x then
    putStrLn "Entered Zero"
  else
    let !y = (liftC succ) =<< readInteger in
    putStrLn ("paired: " ++ (debug (x, y)))