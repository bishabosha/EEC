# Tasks for EEC

[x] desugar operators into list of calls
[-] test how diff postfix levels interact
[?] lazy implementation of tuple
[-] desugar `case x [: !_] of !(a, _) => a ; !x => x` to `let !p = x in case p of (a, _) => a; x => x`

"They rely on giving the products a lazy interpretation: components are only
evaluated once projected out. (So, e.g., the linearity in the rule for 1
is correct because 1 is the empty product and () can never be projected.)"

(i)  Γ | −     ⊢ t: A
(ii) Γ | z: A# ⊢ t: B#

"On the right of Γ is a stoup (following the terminology of [13]),
which may either be empty, as in the case of judgement (i),
or may consist of a unique type assignment z:A,
in which case the type on the right of the turnstyle is also required to be a
computation type, as in (ii)."
  - "The purpose of judgement (i) is merely to assert that the term t has value
    type A in (value) context Γ."
  - "Judgement (ii) asserts that t is a computation of type B (in context Γ)
    which depends linearly on the computation z of type A."

* In branch `unification1`- realised i need to make scope have separate types for
  names that refer to terms and names that refer to pure types
    - e.g. when ! is used as a type `! Integer`, and also to refer to the
      constructor of ! types, e.g. `!0 : ! Integer`

* Note however that since types can currently be only defined in the _root_ pkg
  and there is no user mechanism to define them, then it is safe to substitute
  `TypeRef(a)`, where `a` is unknown, with any concrete type - substitution must
  be propagated

[!] let allows to rebind names to new variable, may need to change to allow for recursion

[!] - DONT IMPLEMENT `::` unless you have implemented multi expr defs

\a => a

(\a -* b) :: A -* B

(,,,,)

!A * B

data Triple =
  Left A | Middle B | End C