# Tasks for EEC

[x] desugar operators into list of calls
[-] test how diff postfix levels interact
[?] lazy implementation of tuple
[-] desugar `case x [: !_] of !(a, _) => a ; !x => x` to `let !p = x in case p of (a, _) => a; x => x`

"They rely on giving the products a lazy interpretation: components are only
evaluated once projected out. (So, e.g., the linearity in the rule for 1
is correct because 1 is the empty product and () can never be projected.)"

* In branch `unification1`- realised i need to make scope have separate types for
  names that refer to terms and names that refer to pure types
    - e.g. when ! is used as a type `! Integer`, and also to refer to the
      constructor of ! types, e.g. `!0 : ! Integer`

* Note however that since types can currently be only defined in the _root_ pkg
  and there is no user mechanism to define them, then it is safe to substitute
  `TypeRef(a)`, where `a` is unknown, with any concrete type - substitution must
  be propagated

[!] let allows to rebind names to new variable, may need to change to allow for recursion

[!] - DONT IMPLEMENT `::` unless you have implemented multi expr defs

\a => a

(\a -* b) :: A -* B

(,,,,)

!A * B

data Triple =
  Left A | Middle B | End C