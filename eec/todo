[ ] desugar operators into list of calls
[ ] test how diff postfix levels interact
[ ] use param to count down args for applications
[ ] lazy implementation of tuple

`t: A`
    -> `let u: !A = !t`

`t: !A`, `u: ~B`, `let !x = t in u`
    -> "evaluate t, bind result to x and continue with u, if z is first within t, then it is first
        within `let !x = t in u`" - *** !x is a pattern match ***

`let x = 2 in x*2`

`products a lazy interpretation: components are only evaluated once projected out. (So, e.g., the linearity in the rule
for 1 is correct because 1 is the empty product and ∗ can never be projected.)`
    -> Tuples are lazy evaluated

`Γ | ∆ ⊢ (λx: A.t)(u) = t[u/x]: B`

`let x = 2 in t` = `(λx.t)(2)`

if stoup has value, type must be comp type, if a value is in the stoop, then the rhs depends linearly on the value in
the stoup, the value in the stoup may also move out of the stoup and remain a valid *type* judgement