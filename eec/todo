[x] desugar operators into list of calls
[-] test how diff postfix levels interact
[?] lazy implementation of tuple
[?] desugar `case x [: !_] of !(a, _) => a ; !x => x` to `let !p = x in case p of (a, _) => a; x => x`

`products a lazy interpretation: components are only evaluated once projected out. (So, e.g., the linearity in the rule
for 1 is correct because 1 is the empty product and ∗ can never be projected.)`
    -> Tuples are lazy evaluated

`Γ | ∆ ⊢ (λx: A.t)(u) = t[u/x]: B`

`let x = 2 in t` = `(λx.t)(2)`

if stoup has value, type must be comp type, if a value is in the stoop, then the rhs depends linearly on the value in
the stoup, the value in the stoup may also move out of the stoup and remain a valid *type* judgement